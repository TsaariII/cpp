// #include <vector>
// #include <deque>
// #include <string>
// #include <iostream>
// #include <cstdlib>
// #include <stdexcept>
// #include <sstream>

// struct block
// {
//     std::string name;
//     int value;
//     std::vector<int> block;
// };


// class PmergeMe
// {
//     private:
//         std::vector<int> _DataVec;
//         std::deque<int> _DataDeq;
//         void _SortVector(std::vector<int>& vec, size_t p_size);
//         void _SortDeque(std::deque<int>& deq);
//         void _PrintVector(const std::string& label, const std::vector<int>& data, size_t p_size);
//         void _PrintDeque(const std::string& label, const std::deque<int>& data);
//     public:
//         PmergeMe();
//         PmergeMe(const PmergeMe& copy);
//         PmergeMe& operator=(const PmergeMe& copy);
//         ~PmergeMe();
//         void readInput(char **argv);
//         void sorter();
// };



// PmergeMe::PmergeMe() {}

// PmergeMe::PmergeMe(const PmergeMe& copy) : _DataVec(copy._DataVec), _DataDeq(copy._DataDeq) {}

// PmergeMe& PmergeMe::operator=(const PmergeMe& copy)
// {
//     if (this != &copy)
//     {
//         _DataVec = copy._DataVec;
//         _DataDeq = copy._DataDeq;
//     }
//     return *this;
// }

// PmergeMe::~PmergeMe() {}

// void PmergeMe::readInput(char **argv)
// {
//     std::set<long> seen;
//     for (int i = 0; argv[i]; i++)
//     {
//         std::string arg(argv[i]);
//         for (size_t j = 0; j < arg.length(); j++)
//         {
//             if(!isdigit(arg[j]))
//                 throw std::invalid_argument("Non-digit character found");
//         }
//         long value = std::strtol(arg.c_str(), NULL, 10);
//         if (value < 0 || value > INT32_MAX)
//             throw std::invalid_argument("Invalid number");
//         if (!seen.insert(value).second)
//             throw std::runtime_error("Duplicate number");
//         _DataVec.push_back(static_cast<int>(value));
//         _DataDeq.push_back(static_cast<int>(value)); 
//     }
// }

// void PmergeMe::sorter()
// {
//     // _PrintVector("Before sorting ", _DataVec, 1);
//     // _PrintDeque("Before:", _DataDeq);
//     // struct timeval start, end;
//     // gettimeofday(&start, NULL);
//     _SortVector(_DataVec, 1);
//     // gettimeofday(&end, NULL);
//     // double vecTime = (end.tv_sec - start.tv_sec) * 1e6 + (end.tv_usec - start.tv_usec);
//     // gettimeofday(&start, NULL);
//     // _SortDeque(_DataDeq);
//     // gettimeofday(&end, NULL);
//     // double deqTime = (end.tv_sec - start.tv_sec) * 1e6 + (end.tv_usec - start.tv_usec);
//     _PrintVector("After:", _DataVec, 1);
//     // _PrintDeque("After:", _DataDeq);
//     // std::cout << "Time to process a range of " << _DataVec.size()
//     //           << " elements with std::vector : " << vecTime << " us" << std::endl;

//     // std::cout << "Time to process a range of " << _DataDeq.size()
//     //           << " elements with std::deque : " << deqTime << " us" << std::endl;
// }

// static std::string to_str(int x) { std::ostringstream os; os << x; return os.str(); }

// std::vector<size_t> generateJacobsthal(size_t size)
// {
//     std::vector<size_t> seq;
//     std::vector<bool> used(size, false);
//     size_t j0 = 0;
//     size_t j1 = 1;
//     if (size == 0)
//         return seq;
//     if (j1 < size)
//     {
//         seq.push_back(j1);
//         used[j1] = true;
//     }
//     while (true)
//     {
//         size_t jn = j1 + 2 * j0;
//         if (jn >= size)
//             break;
//         seq.push_back(jn);
//         used[jn] = true;
//         j0 = j1;
//         j1 = jn;
//     }
//     for (size_t i = 0; i < size; i++)
//     {
//         if (!used[i])
//             seq.push_back(i);
//     }
//     return seq;
// }

// static block make_block(char kind, int pairIdx,
//                         const std::vector<int>& v, size_t start, size_t endInclusive)
// {
//     block r;
//     r.name  = std::string(1, kind) + to_str(pairIdx);
//     r.value = v[endInclusive]; // you chose "last element" as the representative
//     r.block.insert(r.block.end(), v.begin() + start, v.begin() + endInclusive + 1);
//     return r;
// }

// // Build main/pend blocks for a given p_size.
// // - vec: full sequence
// // - p: pair size (block size)
// // - mainBlocks: will get [b1, a1, a2, a3, ...]
// // - pendBlocks: will get [b2, b3, ...]
// // Returns the index where the odd tail starts (i.e., first index not in a full block)
// static size_t build_blocks(const std::vector<int>& vec, size_t p,
//                            std::vector<block>& mainBlocks,
//                            std::vector<block>& pendBlocks)
// {
//     mainBlocks.clear();
//     pendBlocks.clear();

//     const size_t n = vec.size();
//     if (p == 0 || n < p) return 0;

//     // first index NOT part of a full p-sized block
//     const size_t odd_start = n - (n % p);
//     if (odd_start < 2 * p) return odd_start; // not even one full pair

//     int pairIdx = 1;

//     // Emit pairs: for each A block we can form, B is immediately before it
//     for (size_t Aend = 2 * p - 1; (Aend + 1) <= odd_start; Aend += 2 * p, ++pairIdx)
//     {
//         const size_t Astart = Aend - (p - 1);
//         const size_t Bend   = Aend - p;
//         const size_t Bstart = Bend - (p - 1);

//         block bN = make_block('b', pairIdx, vec, Bstart, Bend);
//         block aN = make_block('a', pairIdx, vec, Astart, Aend);

//         if (pairIdx == 1) {
//             // first pair: b1, a1 both in main
//             mainBlocks.push_back(bN);
//             mainBlocks.push_back(aN);
//         } else {
//             // subsequent: aN in main, bN in pend
//             mainBlocks.push_back(aN);
//             pendBlocks.push_back(bN);
//         }
//     }

//     // --- Trailing B block without A? (e.g., b3 for n=22, p=4) ---
//     const size_t fullBlocks = odd_start / p;         // m
//     if (fullBlocks % 2 == 1) {
//         // The last full block is a B at [odd_start - p, odd_start - 1]
//         const size_t Bstart = odd_start - p;
//         const size_t Bend   = odd_start - 1;

//         block bN = make_block('b', pairIdx, vec, Bstart, Bend);

//         // Choose where to put it:
//         // 1) Algorithmically correct (losers list):
//         pendBlocks.push_back(bN);

//         // 2) If you want your debug print to show b1,a1,b2,a2,b3 all together:
//         // mainBlocks.push_back(bN);
//     }

//     return odd_start;
// }

// void PmergeMe::_SortVector(std::vector<int>& vec, size_t p_size)
// {
//     if (p_size == 0 || p_size * 2 > vec.size())
//         return;
//     // std::cout << "|===============|" << std::endl;
//     const size_t step = p_size * 2;
//     // {
//     //     std::ostringstream os;
//     //     os << "Before p_size=" << p_size << " pass: ";
//     //     _PrintVector(os.str(), vec, p_size);
//     // }
//     size_t bi;
//     if (p_size != 1)
//         bi = (p_size * 2) - 1;
//     else
//         bi = 1;
//     for (; bi < vec.size(); bi += step)
//     {
//         const size_t B0 = bi - (p_size -1);
//         const size_t A0 = B0 - p_size;
//         if (vec[bi] < vec[bi - p_size])
//         {
//             // std::cout << "bi = " << bi << std::endl;
//             std::rotate(vec.begin() + A0,
//                         vec.begin() + B0,
//                         vec.begin() + B0 + p_size);
//             // _PrintVector("After rotate swap: ", vec, p_size);
//         }
//     }
//     // {
//     //     std::ostringstream os;
//     //     os << "After  p_size=" << p_size << " pass: ";
//     //     _PrintVector(os.str(), vec, p_size);
//     // }
//     _SortVector(vec, p_size * 2);
//     if (p_size == 4)
//     {
//         std::cout << "Pair size: " << p_size << std::endl;
//         _PrintVector("Before sorting ", vec, 1);
//     }
//     std::vector<block> main;
//     std::vector<block> pend;
//     // size_t odd_s = vec.size() - (vec.size() % p_size);
//     size_t odd_s = build_blocks(vec, p_size, main, pend);
//     std::vector<int> odd(vec.begin() + odd_s, vec.end());
//     if (p_size == 4)
//     {
//         for (size_t i = 0; i < main.size(); i++)
//         {
//             std::cout << "|{name: " << main[i].name
//             << "} {value: " << main[i].value
//             << "} {block: ";
//             for (size_t j = 0; j < main[i].block.size(); j++)
//             std::cout << main[i].block[j] << " ";
//             std::cout << "}|" << std::endl;
//         }
//         for (size_t i = 0; i < pend.size(); i++)
//         {
//             std::cout << "|{name: " << pend[i].name
//             << "} {value: " << pend[i].value
//             << "} {block: ";
//             for (size_t j = 0; j < pend[i].block.size(); j++)
//             std::cout << pend[i].block[j] << " ";
//             std::cout << "}|" << std::endl;
//         }
//     }
//     struct BlockLessByValue {
//         bool operator()(const block& a, const block& b) const
//         {
//             if (a.value != b.value) return a.value < b.value;
//                 return a.name < b.name;
//         }
//     };
//     for (size_t i = pend.size() - 1; i < pend.size(); i--)
//     {
//         std::vector<block>::iterator pos = std::lower_bound(main.begin(), main.end(), pend[i], BlockLessByValue());
//         main.insert(pos, pend[i]);
//     }
//     vec.clear();
//     // pre-reserve to avoid reallocations
//     size_t total = odd.size();
//     for (size_t j = 0; j < main.size(); ++j) total += main[j].block.size();
//     vec.reserve(total);
//     // flatten main blocks
//     for (size_t j = 0; j < main.size(); ++j)
//         vec.insert(vec.end(), main[j].block.begin(), main[j].block.end());
//     // append leftover tail
//     vec.insert(vec.end(), odd.begin(), odd.end());
//     if (p_size == 4)
//         _PrintVector("At the end ", vec, 1);
// }

// void PmergeMe::_SortDeque(std::deque<int>& deq)
// {
//     std::cout << deq[0] << std::endl;
// }

// void PmergeMe::_PrintVector(const std::string& label, const std::vector<int>& data, size_t p_size)
// {
//     std::cout << label << "len (" << data.size() << "): ";
//     size_t step = p_size * 2;
//     size_t i;
//     if (p_size != 1)
//         i = p_size - 1;
//     else
//     {
//         i = 1;
//         step = 1;
//     }
//     size_t j = i - p_size;
//     if (p_size != 1)
//         j = 0;
//     for (; i <= data.size(); i += p_size)
//     {
//         std::cout << "{";
//         if (p_size == 1)
//         {
//             for (; j < i; j++)
//             {;
//                 std::cout << data[j];
//                 if (j != i - 1 && step != 1)
//                     std::cout << " ";
//             }
//         }
//         else
//         {
//             for (; j <= i; j++)
//             {
//                 std::cout << data[j];
//                 if (j != i && step != 1)
//                     std::cout << " ";
//             }
//         }
//         std::cout << "} ";
//     }
//     std::cout << std::endl;

// }

// void PmergeMe::_PrintDeque(const std::string& label, const std::deque<int>& data)
// {
//     std::cout << label;
//     for (size_t i = 0; i < data.size(); i++)
//         std::cout << " " << data[i];
//     std::cout << std::endl;
// }